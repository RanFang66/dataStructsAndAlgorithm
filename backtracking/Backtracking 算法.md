# Backtracking 算法

Backtracking算法一般用在多阶段决策过程中，在每一个决策中会有多种选择，多阶段的决策就会形成一颗决策树，而回溯算法就是对这棵决策树的遍历。

## 一些概念

1. 决策树：将问题的求解过程分为多个决策阶段，每一个决策阶段可以有不同的选择，解决这个问题的所有可能的决策选择序列就构成一棵决策树。

   ```mermaid
   graph TD
   A(stage1)-->|selec 1| B(stage2_1)
   A--> |selec 2| C(stage2_2)
   A--> |selec 3| D(stage2_3)
   A--> |selec ...| E(stage2_...)
   B--> |selec 1| F(stage3_1)
   B--> |selec 2| G(stage3_2)
   B--> |selec ...| H(stage3...)
   ```

2. 路径：已经作出的决策构成的选择序列，其实就是决策树中的一条从从上到下的路径。

3. 选择列表：当前决策中可以做的选择集合。

4. 结束条件：也就是所有的决策已经做完，到达了决策树的底层，无法再做选择的条件。

## 回溯法解决问题的框架

所谓回溯法解决问题，其实就是进行多阶段决策的过程，也就是生成决策树。所谓回溯指的就是在决策树中沿一条路径到到结束条件后，再退回到之前的决策阶段，并做与之前的不同选择，沿另一条路径到达结束条件。

当所有可能的路径都遍历完了之后，其实就相当于生成了一棵决策树，当然实际在解决问题时，可以根据需要直接放弃一些决策路径，减少计算量（剪枝）。

从上面的分析过程中可以看出，这是一个递归的过程，而且递归过程中要有回退到之前的状态重新做选择的步骤。

可以写出回溯算法的解题框架如下：

```python
result = []
def backtrack(当前路径， 当前选择列表)：
	if 满足结束条件：
    	result.add(当前路径)
        return 
    
    for selction in 当前选择列表:			   # 遍历当前阶段的所有可能选择
        make_decision()  				  # 做决策
        backtrack(当前路径， 选择列表)		# 递归
        undo_decision()			   		  # 撤销上一步的决策
```



